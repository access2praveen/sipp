#!/usr/bin/env python



"""Python convert tool for generating AMR-WB test key scenarios from input rtpdump file. 

 

"""

__id__ = '$Id$'

__changelist__ = '$Change$'

__datetime__ = '$DateTime$'

__authors__ = 'Craig Johnston <craig.johnston@dolby.com>'

__copyright__ = 'Copyright (C) 2018 Dolby Laboratories Inc. All rights reserved.'



#TODO: Next steps

# Implement reading and writing options:

## Interleaved

## Robust sorting

# clean up read/write functions to remove major duplication of code

# Find similarities and combine the paths in the read and write code



import socket

import struct

import itertools

import sys



#Output and transformation config items are arrays. Every combination of the output arrays will be output to an autogenerated filename

#The naming scheme is as follows:

# "output_(be|(oa[_rs][_il])([_nt]|[_Xf][Yr][Znd]).rtpdump" where:

# be = Bandwidth Efficient

# oa = Octet Aligned

# rs = Robust sorting

# il = Interleaving

# nt = No transformation of packets has been done (just packing format has changed)

# Xf = X normal (non-redundant) frames of audio

# Yr = Y redundant frames of audio

# Znd = Z redundant NO_DATA frames between the normal and redundant frames



from copy import deepcopy as copy



input_filename = 'input.rtpdump'



#Set the input flags based on the input file's format

input_octet_aligned = False



#Set the output flags to the desired file format

output_octet_aligned = [True]

output_robust_sorting = [True, False]



# If output_transform is False, the number of frames per packet will not change and the original packets with their original headers will be output. If True, all packets headers except the first will be generated

# output_normal_frames controls how many non-redundant frames will be in each packet - Must be 1 or more

# output_redundant_frames controls how many redundant frames will be in each packet - Must be 0 or more

# output_redundant_no_datas controls how many NO_DATA to insert between non-redundant and redundant frames - Must be 0 or more and must be 0 if output_redundant_frames is 0



output_transform = [False, True]

output_normal_frames = [3,4]

output_redundant_frames = [1,2, 4]

output_redundant_no_datas = [0, 1, 5]



#Not supported

input_robust_sorting = False

input_interleaved = False

output_interleaved = [False]



class AMRConfig:

  def __init__(self, octet_aligned, robust_sorting, interleaved):

    self.octet_aligned = octet_aligned

    self.robust_sorting = robust_sorting

    self.interleaved = interleaved



  def __str__(self):

    res = 'OA' if self.octet_aligned else 'BE'

    if self.robust_sorting:

     res += ' RS'

    if self.interleaved:

     res += ' IL'

    return res



class TransformConfig:

  def __init__(self, normal_frames, redundant_frames, redundant_no_datas):

    self.normal_frames = normal_frames

    self.redundant_frames = redundant_frames

    self.redundant_no_datas = redundant_no_datas



class BitStreamReader:

  def __init__(self, data):

    self.data = data

    self.byte_idx = 0

    self.bit_idx = 0



  def skip_byte_pad(self):

    if self.bit_idx != 0:

      self.bit_idx = 0

      self.byte_idx += 1



  def read_bit(self):

    res = self.data[self.byte_idx] & (0x80 >> self.bit_idx)

    self.bit_idx += 1

    if self.bit_idx == 8:

      self.bit_idx = 0

      self.byte_idx += 1

    return 1 if res else 0



  def read_bits(self, count):

    if False: # and count <= 8 - self.bit_idx:

      #Simple case - Just reading from the current byte

      full_mask = [0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff]

      res = (self.data[self.byte_idx] & (full_mask[count] << (8 - count - self.bit_idx))) >> (8 - count - self.bit_idx)

      self.bit_idx += count

      if self.bit_idx == 8:

        self.bit_idx = 0

        self.byte_idx += 1

      return res

    elif count <= 8:

      #Simplish case where there's only one byte of output - Use lazy approach

      res = 0

      while count:

        count -=1

        res <<= 1

        res |= self.read_bit()

      return res

    else:

      #Lazy approach for multiple bytes output

      byte_count = int(count / 8)

      bit_count = count % 8

      #print('Need to read %u bytes and %u bits' % (byte_count, bit_count))

      res = b''

      while byte_count:

        #print(byte_count)

        res += bytes([self.read_bits(8)])

        byte_count -= 1

      res += bytes([self.read_bits(bit_count)])

      return res





class BitStreamWriter:

  def __init__(self):

    self.data = bytearray()

    self.byte_idx = -1

    self.bit_idx = 8



  def pad_to_byte(self):

    if self.bit_idx != 8:

      self.bit_idx = 8



  def write_bit(self, b):

    if self.bit_idx == 8:

      self.bit_idx = 0

      self.data.append(0)

      self.byte_idx += 1



    if b:

      self.data[-1] |= (1 << 7 - self.bit_idx)

    self.bit_idx += 1

    #print('Writing', 1 if b else 0, self.data)



  def write_bits(self, bits, count):

    if count == 0:

      return



    #print('Write %u bits:' % (count), bits)

    byte_count = int(count / 8)

    bit_count = count % 8



    #print(byte_count, bit_count)

    if byte_count == 1 and bit_count == 0:

      byte_count = 0

      bit_count = 8

      #bits = bits[0]



    while byte_count:

      self.write_bits(bits[0], 8)

      bits = bits[1:]

      byte_count -= 1



    #When this loop completes the type of bits is b'' (one character only) or int. The rest of the code expects an int, so convert if needed

    if type(bits) is bytes:

      bits = bits[0]



    temp_bit_count = 0

    #print(byte_count, bit_count, bits)

    while temp_bit_count < bit_count:

      self.write_bit(bits & ((0x01 << (bit_count - 1)) >> (temp_bit_count)))

      temp_bit_count += 1



class AMRPayload:

  def __init__(self, cfg, data = None):

    self.cmr = 0x0f

    self.ill = 0

    self.ilp = 0

    self.frames = []

    self.cfg = cfg



    if data == None:

      return



    bsr = BitStreamReader(data)

    self.cmr = bsr.read_bits(4)

    #print(hex(self.cmr))

    if self.cfg.octet_aligned:

      reserved = bsr.read_bits(4)

      #TODO: Check reserved bits are 0?

      if self.cfg.interleaved:

        self.ill = (data[idx] & 0xf0) >> 4

        self.ilp = data[idx] & 0x0f

        idx += 1



      more = 1

      toc = []

      while more:

        more = bsr.read_bit()

        ft = bsr.read_bits(4)

        q = bsr.read_bit()

        bsr.skip_byte_pad()

        toc.append((ft, q))

        if ft == 14:

          #print('SPEECH_LOST')

          pass

        if ft == 15:

          #print('NO_DATA')

          pass



        if self.cfg.robust_sorting:

          bits_needed = []

          for e in toc:

            bits_needed.append(self.ft_to_bits[e[0]])



          #TODO: Implement reading of robust sorting

          pass

        else:

          for e in toc:

            count = self.ft_to_bits[e[0]]

            amr_bits = b''

            if count:

              #print('Need to read %u bits' % (count))

              amr_bits = bsr.read_bits(count)

              bsr.skip_byte_pad()

              #print(amr_bits)

              #print(str((len(bsr.data) - bsr.byte_idx - 1) * 8 + 8-bsr.bit_idx) + ' bits left over')

            self.frames.append((e[0], e[1], amr_bits))

            #print(len(self.frames))



    else:  #Not octet-aligned

      more = 1

      toc = []

      while more:

        more = bsr.read_bit()

        ft = bsr.read_bits(4)

        q = bsr.read_bit()

        toc.append((ft, q))

        if ft == 14:

          #print('SPEECH_LOST')

          pass

        if ft == 15:

          #print('NO_DATA')

          pass



        for e in toc:

          count = self.ft_to_bits[e[0]]

          amr_bits = b''

          if count:

            #print('Need to read %u bits' % (count))

            amr_bits = bsr.read_bits(count)

            #print(amr_bits)

            #print(str((len(bsr.data) - bsr.byte_idx - 1) * 8 + 8-bsr.bit_idx) + ' bits left over')

          self.frames.append((e[0], e[1], amr_bits))

          #print(len(self.frames))

          #self.xyx = self.pjq



  def write(self):

    bsw = BitStreamWriter()

    bsw.write_bits(self.cmr, 4)

    if self.cfg.octet_aligned:

      bsw.write_bits(0, 4)

      if self.cfg.interleaved:

        #TODO Implement

        pass

      temp_frames = self.frames[:-1]

      last_frame = self.frames[-1]

      #print('XXXX:', len(self.frames), len(temp_frames))

      for t in temp_frames:

        bsw.write_bit(1)

        bsw.write_bits(t[0], 4)

        bsw.write_bit(t[1])

        bsw.write_bits(0, 2) #Padding

      #Last entry in TOC

      bsw.write_bit(0)

      bsw.write_bits(last_frame[0], 4)

      bsw.write_bit(last_frame[1])

      bsw.pad_to_byte() #Padding



      if self.cfg.robust_sorting:

        temp = []

        for t in self.frames:

          if self.ft_to_bits[t[0]] != 0:    #Skip NO_DATA

            tbsw = BitStreamWriter()

            tbsw.write_bits(t[2], self.ft_to_bits[t[0]])

            tbsw.pad_to_byte() #Padding

            temp.append((self.ft_to_bits[t[0]], tbsw.data))



        i = 0

        done = 0

        while done != len(temp):

          for t in temp:

            if i < len(t[1]):

              bsw.write_bits(t[1][i], 8)

            if i == len(t[1]):   #Once we've passed the end, we're done with this frame

              done += 1

          i += 1

      else:

        #Write rest of the payload

        for t in self.frames:

          bsw.write_bits(t[2], self.ft_to_bits[t[0]])

          bsw.pad_to_byte() #Padding



    else:  #Not octet-aligned

      #Write TOC

      temp_frames = self.frames[:-1]

      last_frame = self.frames[-1]

      for t in temp_frames:

        bsw.write_bit(1)

        bsw.write_bits(t[0], 4)

        bsw.write_bit(t[1])

      #Last entry in TOC

      bsw.write_bit(0)

      bsw.write_bits(last_frame[0], 4)

      bsw.write_bit(last_frame[1])



      #Write rest of the payload

      for t in self.frames:

        bsw.write_bits(t[2], self.ft_to_bits[t[0]])



    return bsw.data



  ft_to_bits = [132, 177, 253, 285, 317, 365, 397, 461, 477, 40, -1, -1, -1, -1, 0, 0]



class RTPPacket:

  def __init__(self, amr_cfg, data = None):

    self.version = 0

    self.padcount = 0;

    self.marker = 0

    self.sequence = 0

    self.timestamp = 0

    self.ssrc = 0

    self.csrc = []

    self.extension_type = 0

    self.extension_data = b''

    self.payload = b''

    self.amr = AMRPayload(amr_cfg)

    self.payload_type = 0xff



    if data == None:

      return



    self.version = (data[0] & 0xC0) >> 6

    self.padcount = data[-1] if (data[0] & 0x20) else 0

    extension = data[0] & 0x10

    csrc_count = data[0] & 0x0f



    self.marker = data[1] & 0x80

    self.payload_type = data[1] & 0x7f

    (self.sequence, self.timestamp, self.ssrc) = struct.unpack_from('!HII', data[2:12])



    idx = 12

    while csrc_count:

      self.csrc.append(struct.unpack_from('!I', data[idx:idx+4]))

      idx += 4

      csrc_count -= 1



    if extension:

      self.extension_type = struct.unpack_from('!H', data[idx:idx+2])

      idx += 2

      extension_size = struct.unpack_from('!H', data[idx:idx+2]) * 4

      idx += 2

      self.extension_data = data[idx:idx+extension_size]

      idx += extension_size



    self.payload = data[idx:] if self.padcount == 0 else data[idx:-self.padcount]

    self.amr = AMRPayload(amr_cfg, self.payload)



  def write(self):

    res = b''

    res += bytes([(self.version << 6) | ((1 << 5) if self.padcount else 0) | ((1 << 4) if self.extension_type else 0) | len(self.csrc)])

    res += bytes([((1 << 7) if self.marker else 0) | self.payload_type])

    #print((self.sequence, self.timestamp, self.ssrc))

    res += struct.pack('!HII', self.sequence, self.timestamp, self.ssrc)

    for c in self.csrc:

      res += struct.pack('!I', c)



    if self.extension_type:

      res += struct.pack('!H', self.extension_type)

      res += struct.pack('!H', len(self.extension_data))

      res += self.extension_data



    res += self.amr.write()

    return res



class RTPDumpPacket:

  def __init__(self, amr_cfg, length, time, data = None):

    self.length = length

    self.time = time

    self.data = b''

    self.rtp = RTPPacket(amr_cfg)



    if data == None:

      return



    #print(self.length, 'bytes read for packet')

    self.data = data

    self.rtp = RTPPacket(amr_cfg, data)



  def write(self):

    rtp_data = self.rtp.write()



    #print('RTP len:', len(rtp_data), 'RTPDUMP len:', self.length)

    self.length = len(rtp_data)

    #print(self.length, 'bytes written for packet')

    res = struct.pack('!HHI', self.length + 8, self.length, self.time)  #TODO: We are assuming that all packets were fully captured - Verify?

    res += rtp_data

    return res



class RTPDump:

  def __init__(self, amr_cfg, f = None):



    self.error = ''    #If not empty, the reason the file is invalid

    self.destination_addr = ''

    self.destination_port = 0

    self.binary_header = b''

    self.packets = []



    if f == None:

      return



    self.read_header(f)

    if self.error != '':

      return

    self.read_dest_address(f)

    if self.error != '':

      return

    self.read_dest_port(f)

    if self.error != '':

      return



    #Just save the bytes foir the source address info and GMT start time and hen output them again when writing

    self.binary_header = f.read(16)



    data = f.read(8)

    while len(data) == 8:

      pkt_hdr = struct.unpack('!HHI', data)

      self.packets.append(RTPDumpPacket(amr_cfg, pkt_hdr[1], pkt_hdr[2], f.read(pkt_hdr[0] - 8)))

      data = f.read(8)



    print(str(len(self.packets)) + " packets read")



  def set_output_cfg(self, amr_cfg):

    for i in range(len(self.packets)):

      self.packets[i].rtp.amr.cfg = amr_cfg



  def write(self, filename):

    with open(filename, 'wb') as f:

      f.write(b'#!rtpplay1.0 ')

      f.write(self.destination_addr.encode('utf-8'))

      f.write(b'/')

      f.write(str(self.destination_port).encode('utf-8'))

      f.write(b'\n')

      f.write(self.binary_header)

      for p in self.packets:

        f.write(p.write())



  def read_header(self, f):

    if f.read(9) != b'#!rtpplay':

      self.error = 'Missing magic values'

      return

    ver = f.read(3).decode('utf-8')

    if ver != '1.0':

      self.error = 'Invalid version'

      return

    if f.read(1) != b' ':

      self.error = 'Missing space after version'

      return

    return ver



  def read_until(self, f, char, limit):

    b = f.read(1)

    data = b''

    while b != char:

      data += b

      if len(data) >= limit:

         return b''

      b = f.read(1)

    return data



  def read_dest_address(self, f):

    data = self.read_until(f, b'/', 40)

    text = data.decode('utf-8')

    text = text.split('.')

    if len(text) != 4:

      self.error = 'Unable to find valid destination address'

      return

  

    addr = []

    try:

      for t in text:

        addr.append(str(int(t)))

    except ValueError:

      self.error = 'Unable to find valid destination address'

      return

    self.destination_addr = '.'.join(addr)



  def read_dest_port(self, f):

    data = self.read_until(f, b'\n', 40)

    text = data.decode('utf-8')

    try:

      self.destination_port = int(text)

    except ValueError:

      self.error = 'Unable to find read valid destination port'





def read_rtp_dump(filename, amr_cfg):

  with open(filename, 'rb') as f:

    return RTPDump(amr_cfg, f)





def transform(rtp_dump, amr_cfg, trans_cfg):

  if trans_cfg == None:

    return rtp_dump



  res = RTPDump(amr_cfg)

  res.destination_addr = rtp_dump.destination_addr

  res.destination_port = rtp_dump.destination_port

  res.binary_header = rtp_dump.binary_header



  time = rtp_dump.packets[0].time

  first_rtp = rtp_dump.packets[0].rtp



  frames = []

  for p in rtp_dump.packets:

    frames.extend(p.rtp.amr.frames)



  #print(len(frames), 'frames in total')



  for i in range(0, len(frames) + trans_cfg.redundant_frames + trans_cfg.redundant_no_datas, trans_cfg.normal_frames):

    #Create new packet

    newp = RTPDumpPacket(amr_cfg, 0, time)

    time += 20 * trans_cfg.normal_frames



    newp.rtp = copy(first_rtp)



    #Overwite timetamp and marker and amr payloads

    newp.rtp.timestamp = first_rtp.timestamp + i * (20 * 16)

    newp.rtp.sequence = first_rtp.sequence + int(i/trans_cfg.normal_frames)

    newp.rtp.marker = 1 if i == 0 else 0



    redundant = []

    no_datas = []

    normal = []

    

    #Insert redundant frames

    for k in range(trans_cfg.redundant_frames):

      j = k - trans_cfg.redundant_frames - trans_cfg.redundant_no_datas

      if i + j >= 0:

        if i + j < len(frames):

          redundant.append(frames[i + j])

      else:

        redundant.append((15, 1, b'')) #use NO_DATA as the redundant data (because we don't have the frame available (off the leading edge))

 

    for k in range(trans_cfg.redundant_no_datas):

        no_datas.append((15, 1, b''))

 

    #Now the normal frames

    for j in range(trans_cfg.normal_frames):

      if i + j < len(frames):

        normal.append(frames[i + j])

 

    #Construct so that there are no trailing NO_FRAMES

    temp = copy(redundant)

    if len(normal) > 0:

      temp.extend(no_datas)

    temp.extend(normal)

 

    #print('New packet with', len(temp), 'AMR-WB frames', len(redundant), len(no_datas), len(normal))

    if len(temp) > 0: #Avoid empty packets

      newp.rtp.amr.frames = temp

      res.packets.append(newp)



  return res



def generate_filename(amr_cfg, trans_cfg = None):

  res = 'output_' + ('oa' if amr_cfg.octet_aligned else 'be')

  if amr_cfg.robust_sorting:

    res += '_rs'

  if amr_cfg.interleaved:

    res += '_il'



  if trans_cfg == None:

    res += '_nt'

  else:

    res += '_' + str(trans_cfg.normal_frames) + 'f'

    if trans_cfg.redundant_frames:

      res += '_' + str(trans_cfg.redundant_frames) + 'r'

    if trans_cfg.redundant_no_datas:

      res += '_' + str(trans_cfg.redundant_no_datas) + 'nd'



  res += '.rtpdump'

  return res



def write_rtp_dump(rtp_dump, output_cfg, trans_cfg):

  rtp_dump.set_output_cfg(output_cfg)

  output_filename = generate_filename(output_cfg, trans_cfg)

  print('Writing', output_filename)

  rtp_dump.write(output_filename)



input_cfg = AMRConfig(input_octet_aligned, input_robust_sorting, input_interleaved)

rtp_dump = read_rtp_dump(input_filename, input_cfg)

if rtp_dump.error != '':

  print('Failure to read file:', rtp_dump.error)

  sys.exit(0)



#Generate and execute every config combination desired

output_configs = []

for align in output_octet_aligned:

  if align:

    for rs in output_robust_sorting:

      for il in output_interleaved:

        output_configs.append(AMRConfig(align, rs, il))

  else:

    output_configs.append(AMRConfig(align, False, False))



trans_configs = []

for trans in output_transform:

  if trans:

    for f in output_normal_frames:

      for r in output_redundant_frames:

        if r != 0:    #Only allow NO_DATA if redundancy used

          for nd in output_redundant_no_datas:

            trans_configs.append(TransformConfig(f, r, nd))

        else:

          trans_configs.append(TransformConfig(f, r, 0))

  else:

    trans_configs.append(None)



#Execute

for oc in output_configs:

  for tc in trans_configs:

    output_rtp_dump = transform(rtp_dump, oc, tc)

    write_rtp_dump(output_rtp_dump, oc, tc)
